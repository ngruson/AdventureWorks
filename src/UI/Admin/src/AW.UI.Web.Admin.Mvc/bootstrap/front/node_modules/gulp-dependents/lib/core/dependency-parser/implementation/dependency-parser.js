"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyParser = exports.defaultConfig = void 0;
var path = __importStar(require("path"));
/**
 * Represents the default configuration for the dependency tracker, specifying
 * how dependencies should be parsed from each of the supported file types.
 */
exports.defaultConfig = {
    ".pcss": {
        postfixes: [".pcss"],
        parserSteps: [
            /(?:^|;|}|\*\/)\s*@import\s+(?:"([^"]+)"|'([^']+)'|url\((?:"([^"]+)"|'([^']+)'|([^)]+))\))/gm
        ]
    },
    ".less": {
        parserSteps: [
            // The language semantics only allow import statements with a single file path.
            // Therefore, we can extract the path directly.
            /(?:^|;|}|\*\/)\s*@import\s+(?:\([^)]*\)\s*)?(?:"([^"]+)"|'([^']+)'|url\((?:"([^"]+)"|'([^']+)'|([^)]+))\))(?=;)/gm
        ],
        prefixes: [],
        postfixes: [".less"],
        basePaths: []
    },
    ".scss": {
        parserSteps: [
            // The language semantics allow import statements with a comma-separated list of file paths.
            // Therefore, we first extract the whole statement, and then extract each of the paths from that.
            /(?:^|;|{|}|\*\/)\s*@(import|use|forward)\s+((?:"[^"]+"|'[^']+'|url\((?:"[^"]+"|'[^']+'|[^)]+)\))(?:\s*,\s*(?:"[^"]+"|'[^']+'|url\((?:"[^"]+"|'[^']+'|[^)]+)\)))*)(?=[^;]*;)/gm,
            /"([^"]+)"|'([^']+)'|url\((?:"([^"]+)"|'([^']+)'|([^)]+))\)/gm
        ],
        prefixes: ["_"],
        postfixes: [".scss", ".sass"],
        basePaths: []
    },
    ".sass": {
        parserSteps: [
            // The exact language semantics are not well documented, but it appears it might allow multi-line import statements.
            // However, we only support single-line statements, as RegExp is not good at reliably matching indent-based syntax.
            /^\s*@import\s+(.*)$/gm,
            /"([^"]+)"|'([^']+)'|url\((?:"([^"]+)"|'([^']+)'|([^)]+))\)|([^\s]+)/gm
        ],
        prefixes: ["_"],
        postfixes: [".scss", ".sass"],
        basePaths: []
    }
};
/**
 * Represents a parser that extracts dependency file paths from a file.
 */
var DependencyParser = /** @class */ (function () {
    /**
     * Creates a new instance of the type.
     * @param config The configuration to merge with the default configuration.
     */
    function DependencyParser(config) {
        /**
         * The configuration describing how files should be parsed.
         */
        this.config = {};
        // Apply the default config.
        this.applyConfig(exports.defaultConfig);
        // Apply the custom config.
        this.applyConfig(config);
    }
    /**
     * Parses the specified file, returning the set of dependency file paths on which it depends.
     * @param file The file for which dependencies should be returned.
     * @param encoding The name of the encoding used in the file.
     * @return The set of file paths on which the file depends.
     */
    DependencyParser.prototype.getDependencyFilePaths = function (file, encoding) {
        // Get the configuration for the file type.
        var config = this.config[path.extname(file.path).toLowerCase()];
        // Ignore file types for which we have no config.
        if (!config) {
            return null;
        }
        // Get the dependency paths specified in the file.
        var dependencyPaths = this.parseFile(file, config);
        // Ignore dependency paths representing URL's.
        dependencyPaths = dependencyPaths.filter(function (path) {
            return !path.match(/http:|https:|ftp:|file:/);
        });
        // Add path variants for all prefix and postfix variants.
        if (config.prefixes) {
            this.getPrefixedPathVariants(dependencyPaths, config)
                .forEach(function (dependencyPath) { return dependencyPaths.push(dependencyPath); });
        }
        if (config.postfixes) {
            this.getPostfixedPathVariants(dependencyPaths, config)
                .forEach(function (dependencyPath) { return dependencyPaths.push(dependencyPath); });
        }
        if (config.basePaths) {
            this.getBasePathVariants(dependencyPaths, config)
                .map(function (dependencyPath) { return path.resolve(path.dirname(file.base), dependencyPath); })
                .forEach(function (dependencyPath) { return dependencyPaths.push(dependencyPath); });
        }
        // Reduce the list of paths to a unique set of normalized paths.
        var uniqueDependencyPaths = {};
        dependencyPaths.forEach(function (dependencyPath) { return uniqueDependencyPaths[path.normalize(dependencyPath)] = true; });
        // Resolve paths to absolute paths.
        return Object.keys(uniqueDependencyPaths)
            .map(function (dependencyPath) { return path.resolve(path.dirname(file.path), dependencyPath); });
    };
    /**
     * Parses the specified file, returning the set of paths specified in its dependency statements.
     * Note that those are not yet valid file paths, as prefixes and postfixes may be missing.
     * @param file The file for which dependency paths should be returned.
     * @param config The parser config for the file type being parsed.
     * @return The set of paths specified in the files dependency statements.
     */
    DependencyParser.prototype.parseFile = function (file, config) {
        // Read the file contents as a string.
        var fileContents = file.contents.toString();
        // Iteratively reduce the file contents to a set of dependency references.
        var dependencyPaths = [fileContents];
        for (var _i = 0, _a = config.parserSteps; _i < _a.length; _i++) {
            var regExpOrFunc = _a[_i];
            dependencyPaths = this.getMatches(dependencyPaths, regExpOrFunc);
        }
        return dependencyPaths;
    };
    /**
     * Applies the specified RegExp or function to each of the specified texts, aggregating all the captured
     * values into a single list.
     * @param texts The texts against which the RegExp or function should be executed.
     * @param regExpOrFunc The RegExp or function to be executed. If the parameter is a RegExp, it must have
     * a single capture group representing the string to be matched. If the parameter is a function, it must
     * accept a string and return an array of matched strings.
     * @return An array containing all the matches found in all the texts.
     */
    DependencyParser.prototype.getMatches = function (texts, regExpOrFunc) {
        var results = [];
        for (var _i = 0, texts_1 = texts; _i < texts_1.length; _i++) {
            var text = texts_1[_i];
            if (regExpOrFunc instanceof Function) {
                for (var _a = 0, _b = regExpOrFunc(text); _a < _b.length; _a++) {
                    var match = _b[_a];
                    if (match != null) {
                        results.push(match);
                    }
                }
            }
            else if (regExpOrFunc instanceof RegExp) {
                var match = void 0;
                while (match = regExpOrFunc.exec(text)) {
                    for (var i = 1; i < match.length; i++) {
                        if (match[i] != null) {
                            results.push(match[i]);
                        }
                    }
                }
            }
        }
        return results;
    };
    /**
     * Applies the prefixes in the specified config to the specified paths, returning the resulting set of path variants.
     * @param dependencyPaths The dependency paths for which variants should be returned.
     * @param config The parser config for the file type being parsed.
     * @return A list of prefixed path variants.
     */
    DependencyParser.prototype.getPrefixedPathVariants = function (dependencyPaths, config) {
        var variants = [];
        for (var _i = 0, dependencyPaths_1 = dependencyPaths; _i < dependencyPaths_1.length; _i++) {
            var dependencyPath = dependencyPaths_1[_i];
            for (var _a = 0, _b = config.prefixes; _a < _b.length; _a++) {
                var prefix = _b[_a];
                var variant = path.join(path.dirname(dependencyPath), prefix + path.basename(dependencyPath));
                variants.push(variant);
            }
        }
        return variants;
    };
    /**
     * Applies the postfixes in the specified config to the specified paths, returning the resulting set of path variants.
     * @param dependencyPaths The dependency paths for which variants should be returned.
     * @param config The parser config for the file type being parsed.
     * @return A list of path variants, with default file names appended to each folder path.
     */
    DependencyParser.prototype.getPostfixedPathVariants = function (dependencyPaths, config) {
        var variants = [];
        for (var _i = 0, dependencyPaths_2 = dependencyPaths; _i < dependencyPaths_2.length; _i++) {
            var dependencyPath = dependencyPaths_2[_i];
            for (var _a = 0, _b = config.postfixes; _a < _b.length; _a++) {
                var postfix = _b[_a];
                var variant = dependencyPath + postfix;
                variants.push(variant);
            }
        }
        return variants;
    };
    /**
     * Applies the alternate base paths in the specified config to the specified paths, returning the resulting set of path variants.
     * @param dependencyPaths The dependency paths for which variants should be returned.
     * @param config The parser config for the file type being parsed.
     * @return A list of postfixed path variants.
     */
    DependencyParser.prototype.getBasePathVariants = function (dependencyPaths, config) {
        var variants = [];
        for (var _i = 0, dependencyPaths_3 = dependencyPaths; _i < dependencyPaths_3.length; _i++) {
            var dependencyPath = dependencyPaths_3[_i];
            // HACK: We should use path.isAbsolute(...), but it's not supported by the node version shipping with Visual Studio.
            if (!dependencyPath.match(/^[\/]/) && !dependencyPath.match(/^.*:/)) {
                for (var _a = 0, _b = config.basePaths; _a < _b.length; _a++) {
                    var basePath = _b[_a];
                    var variant = path.join(basePath, dependencyPath);
                    variants.push(variant);
                }
            }
        }
        return variants;
    };
    /**
     * Applies the specified configuration by merging it into the current configuration.
     * @param config The configuration to merge with the current configuration.
     */
    DependencyParser.prototype.applyConfig = function (config) {
        if (config) {
            for (var _i = 0, _a = Object.keys(config); _i < _a.length; _i++) {
                var fileNameExtension = _a[_i];
                var currentConfig = config[fileNameExtension];
                if (!currentConfig) {
                    this.config[fileNameExtension] = null;
                }
                else if (!this.config[fileNameExtension]) {
                    if (!currentConfig.parserSteps || !currentConfig.parserSteps.length) {
                        throw new Error("A new file type configuration must specify at least one RegExp.");
                    }
                    this.config[fileNameExtension] = currentConfig;
                }
                else {
                    for (var _b = 0, _c = Object.keys(currentConfig); _b < _c.length; _b++) {
                        var key = _c[_b];
                        this.config[fileNameExtension][key] = currentConfig[key];
                    }
                }
            }
        }
    };
    return DependencyParser;
}());
exports.DependencyParser = DependencyParser;
